Get Rank Documentation
------------

### Вводная
Данный проект использует лучшие подходы и актуальные решения на сегодняшний день.

##### Девелопер-Роадмап для проекта
Ознакомится c роадмапом и лучшими инструментами можно перейдя по ссылке: [developer-roadmap](https://github.com/kamranahmedse/developer-roadmap)

##### Концепты и шаблоны
Проект для удобства/скорости/поддерживаемости использует следующие:

* За основу выбрана идея [Atomic design](https://bradfrost.com/blog/post/atomic-web-design/)
* Следует придерживаться подходов [SOLID](https://ota-solid.now.sh/) и [GRASP](https://bool.dev/blog/detail/grasp-printsipy)
* Так же шаблонов проектирования [Refactoring-Guru](https://refactoring.guru/ru/design-patterns) и [часть примеров GOF на TS](https://github.com/Uncleseneca/typescript_design_patterns)

### Инструменты

##### Пользовательских интерфейс - [React](https://ru.reactjs.org/) и [Документация](https://ru.reactjs.org/docs/getting-started.html)

##### Стилизация пользовательского интерфейса - [Styled-components](https://styled-components.com/) и [Документация](https://styled-components.com/docs4)

##### Хранилище/Стор - [Mobx](https://mobx.js.org/README.html) в связке [Mobx-State-Tree](https://mobx-state-tree.js.org/)

##### Роутинг - [Router5](https://router5.js.org/)

##### Формы - [Formik](https://formik.org/docs/overview)

##### HTTP клиент - [Axios](https://github.com/axios/axios)

# Запуск проекта
Управлени и сборка проекта происходит через [CRA](https://create-react-app.dev/)

### Установка зависимостей

```sh
$ yarn install
```

### Старт проекта в дев режиме

```sh
$ yarn start
```

### Сборка проекта

```sh
$ yarn build
```

### Автоматическое форматирование кода

```sh
$ yarn format
```

# Структура проекта
Структура файлов, папок и их именования согласно правил каждой структуры, что описана ниже.

### Главная структура проекта

    .
    ├── common/                 общие файлы с бэкендом
    │
    ├── src/
    │   ├── assets/             папка для статичиских файлов
    │   ├── atoms/              компоненты которые не имеют логики
    │   ├── components/         компоненты общего использования с одной бизнес логикой или обвертки для других
    │   ├── enums/              множество значений для списка идентификаторов
    │   ├── hooks/              набор общих хуков для управления бизнес-логики или для общих компоннтов
    │   ├── interfaces/         множество общих интерфейсов
    │   ├── models/             модели для управления данными стора и получения от сервера
    │   ├── pages/              набор страниц и подстраниц
    │   ├── root/               инициализация приложения и общие параметры для стилей
    │   ├── router/             конфигурация по роутингу
    │   ├── selectors/          селекторы для получения данных со стора
    │   ├── store/              инициализация и управления хранилищем
    │   ├── types/              множество общих типов
    │   ├── utils/              вспомогательные функции для работы компонентов
    │   └── index.ts            точка входа приложения
    │
    ├── .eslint                 инструмент статического анализа кода
    ├── prettierrc              инструмент для стилизации код
    ├── config-overrides.js     конфигуратор CRA
    ├── pathes.config.js        конфигуратор путей проекта
    ├── tsconfig.json           конфигуратор TS
    └── tsconfig.paths.json     конфигуратор путей проекта для TS

### Cтруктура assets
Assets может включать в себя статические медиа файлы формата: *.svg, *.png, *.jpg, *.mp4 и т.д. Использоваться могут для нескольких в атомов.

    .
    ├── assets/
        ├── logo.svg
        └── ...    

### Cтруктура atoms
Atoms в себе хранит набор компонентов которые не решают и не знают ничего про бизнес логику, хранилища и управления приложения. Должны строиться на принципе "The Single Responsibility Principle". Могут иметь "The Interface Segregation Principle" для управления состоянием. И имеют связку только от внутреннего состояния предоставляя внешний набор правил(The Dependency Inversion Principle).

Меняют свое отображение или поведения от входящих параметров. Предоставляют API для получения событий.

Не могут включать в себя компоненты, атомы или селекторы. Не могут решать или менять самостоятельно свои состояния. Не могут управлять состоянием хранилищем.

    atoms/
    ├── atom-name/
        ├── atom-name.styles.ts      набор стилей для компонента (required)
        ├── atom-name.tsx            компонент(атом) для отображения и переиспользования (required)
        │
        ├── atom-name.props.ts       интерфейс, если необходимо унаследоваться для детей-клонов (optional)    
        ├── atom-name-child.tsx      компонент(атом) для отображения и переиспользования унаследованый от основного атома (optional)
        │
        └── ...    

### Cтруктура components
Компоненты это те же атомы, но уже могут участвовать в решении одной конкретной бизнес логики или быть вспомогательными обвертками для решения поставленной задачи. Унаследуют все те же принципы и подходы от атомов. Могут использовать принцип "The Open Closed Principle" для расширения работы. Чтение и управление состоянием хранилища происходит через селекторы. Селекторы могут быть внутренними, так и подключаемыми.

Компонент может быть молекулой или организмом из иерархии атомного дизайна. Компонент-организм может в себе иметь саб-компоненты молекулы или организмы.

Компонент включает себя атомы, реагирует на их события. Может в себя включать свои селекторы/хуки для управления связкой между несколькими атомами(скорее исключение). Может иметь свои селекторы для обработки входящих данных под структуру компонентов/атомов. Слушают события и передают данные через селекторы.

Не могут включать в себя компоненты. Не могут управлять состоянием хранилищем.

    components
    ├── component-name/
        ├── component-name-child        подкомпоненты            
        │    ├── ...
        │    │    └── ...          
        │    └── ... 
        │   
        ├── component-name.styles.ts    набор стилей для компонента (required)
        ├── component-name.tsx          компонент для отображения и переиспользования (required)
        │        
        ├── component-name.props.ts     интерфес компонента для наследования (optional)
        ├── component-name.selector.ts  селектор для обработки и/или управления данными в самом компоненте (optional)    
        └── component-name.options.ts   наборы правил для отображения и управления компонентом (optional)     

### Cтруктура enums
Множество конкретных значений идентификаторов для конкретной задачи.

Именование файла enum: **имя-идентификаторов**.enum.ts

Именование списка enum: **Имя**Enum

    enums
        ├── enum-name.enum.ts
        └── ...    

### Cтруктура hooks
Набор общих хуков для управления бизнес логики(не включая хранилище) или для общих компонентов.

Именование файла hook: use-**имя-хука**.hook.ts

Именование hook-а: use**ИмяХука**

    hooks
        ├── use-hook-name.hook.ts
        └── ...        

### Cтруктура interfaces
Набор общих хуков для управления бизнес логики(не включая хранилище) или для общих компонентов.

Именование файла hook: **имя-интерфейса**.interface.ts

Именование hook-а: **ИмяИнтерфейса**Interface

    interfaces
        ├── interface-name.interface.ts
        └── ...            

### Cтруктура models
Модели для работы с хранилищем. Предоставляют возможность для хранения данных, описывают структуру и дают методы для работы с данными. Работают с API запросами. Могут предоставлять видоизмененный интерфейс структуры данных("The Open Closed Principle"). Могут частично брать на себя ответственность в управлении бизнес логики(скорее исключение из правил).

Не меняют структуру данных. Не обрабатывают структуру данных. Не решают и не знают о типе отображаемых компонентов.

Именование каталога model: **имя-модели**

Именование файла model: **имя-интерфейса**.ts

Именование model: **ИмяМодели**Model

    models
        ├── name-model
        │   ├── name-model.initial.ts       создает первоначальные данные для модели по умолчанию (required)
        │   ├── name-model.interface.ts     описывает интерфес данных модели (required)
        │   ├── name-model.ts               описание модели согласно mobx-state-tree (required)
        │   │
        │   └── name-model.types.ts         описание типов модели согласно mobx-state-tree (optional) 
        └── ...                

### Cтруктура pages
Основная идея разделения страниц основана на концепции [Router5](https://router5.js.org/) и микро сервисной архитектуре. В основе лежит Getaway который, управляет отображению той или иной страницы. Под странницей можем считать приложение, которое не связано между собой или данными из стора.

Страница может быть страницей или шаблоном из иерархии атомного дизайна. Страница или шаблон могут включать в себя **только** собственные селекторы, которые могут быть унаследованы от общих. Могут управлять отображением компонентов в зависимости от данных(скорее исключение).

Страницы состоят из компонентов и/или атомов.

Страница не может включать в себя другие страницы. Управлять хранилищем. Управлять и работать с бизнес логикой. Не могут влиять на работу компонентов и взаимодействовать с API атомов.

    pages
        ├── name-page
        │   ├── name-page.styles.ts     cтили для страницы / шаблонов (required)
        │   └── name-page.tsx           cтраница / Шаблон (required)
        │   
        └── page-root.ts                файл управия между страницами (required)

### Cтруктура root
В этом каталоге есть 2 управления: инициализация приложения и общие данные для стилей.

*Именование палитры цветов происходит по средствам:* [Chirag](http://chir.ag/)

    root
        ├── application
        │   ├── application.styles.ts   стили для приложения (required)
        │   └── application.tsx         инициализация приложения (required)
        │   
        └── styles
            ├── animation.ts  
            ├── colors.ts        
            └── ...

### Cтруктура router
В этом каталоге происходит конфигурация роутинга. Роутинг делится на страницы и их под страницы.

Именование файла route: **имя-роута**.route.ts

Именование route: **ИмяРоута**Router

    router
        ├── name-route.route.ts     конфигурация роутинга для страницы
        ├── ...
        │  
        ├── create-router.ts        инициализация роутинга, может быть расширяемый мидлварами
        └── routes.ts               комбинатор роутов

### Cтруктура selectors
Селекторы делятся на под каталоги по делению области ответственности. Селекторы отвечают за работу со стором, подготовку данных и предоставления методов для обновления. Управляют поставленной бизнес логикой.

Именование файла route: use-**имя-селекторв**.selector.ts

Именование route: **ИмяРоута**Router

    selectors
        ├── name-selectors
        │   ├── use-name-selectors.selector.ts
        │   └── ...
        └── ...

### Cтруктура store
Хранилище и его инициализация.

    store
        ├── root-store.ts       инициализация хранилища
        └── store-context.ts    контекст для селекторов

### Cтруктура types
Каталог множества общих типов.

Именование файла type: **имя-типа**.type.ts

Именование type-а: **ИмяТипа**Type

    types
        ├── type-name.type.ts
        └── ...            
